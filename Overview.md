## Introduction ##

In a development environment different people will have different modelling needs to be able to work with different types of simulation, deployment, validation, etc.. This can often lead to communication problems, introduction of conversion bugs, etc., when one work step forwards its data to the next (often in the form of Excel Sheets, Word Documents, etc.). One way to avoid this problem is to define [metamodels](http://en.wikipedia.org/wiki/Metamodeling) for the different work steps, capture the information in the specific work steps in model instances (adhering to the metamodel for that particular work step) and forwarding the data between work steps by translating the model instances.

The code in this repository will allow you to exchange a certain information set between [EAST-ADL](http://en.wikipedia.org/wiki/EAST-ADL) Models and [Simulink](http://en.wikipedia.org/wiki/Simulink). The exchange is bi-directional; the transferable set of information can be moved from a EAST-ADL Model instance to Simulink, modified and then transferred back to a EAST-ADL Model instance, and vice versa.

## Architecture ##

### Meta-Models, Meta-Meta-Models ###

The [Eclipse Modeling Framework](http://www.eclipse.org/modeling/emf/) is a group of Java libraries for Model-Driven development. The Core EMF framework includes a meta-metamodel (Ecore) for describing models and run-time support for the models, including change notification, persistence support with default XMI serialization, and a reflective API for manipulating EMF objects generically. In other words, Ecore is a meta-metamodel, defining the structure of core models, which define the structure of the models developers use to maintain application data.

Besides Ecore, this project is concerned with two metamodels:

  * The [Simulink metamodel](SimulinkMetamodel.md) defined at KTH.
  * The EAST-ADL metamodel generated by our [French Partners from CEA](http://www.papyrusuml.org/home/index.htm).

... both these metamodels are implemented with the elements provided by Ecore (i.e. the meta-metamodel for all the model instances in our project).

### Tools ###

The following tools are involved in this project:

  * <b><a href='http://www.eclipse.org/'>Eclipse</a></b>: An open-source, Java based, extendible Integrated Development Enviroment (IDE).

  * <b><a href='http://www.papyrusuml.org/home/index.htm'>Papyrus</a></b>: An UML editor built on top of Eclipse and EMF.

  * <b><a href='http://wiki.eclipse.org/ATL'>Atlas Transformation Language M2M Component</a>:</b> We use the ATL Component in M2M to convert models from one side to the other (hence the need for Metamodels, without which ATL could not be used).

  * <b><a href='http://www.mathworks.com/'>MATLAB</a>:</b> MATLAB is a numerical computing environment and fourth-generation programming language.

  * <b>JUnit4 and JExample</b>: The Test Strategy and How-to can be found [here](TestStrategy.md).

  * <b>Doxygen and Eclox</b>: Documentation is generated with Doxygen, while Eclox is used to interact with Doxygen from within Eclipse. The Documentation Strategy and How-to can be found [here](DocumentationStrategy.md).

The Development Environment is described in detail [here](DevelopmentEnvironment.md).

### Interaction of the parts ###

This picture shows the components involved in the process.

![https://docs.google.com/drawings/pub?id=1n4Ai_A5LxWkymQBnc1E4DvBvsQ4pku5S6RwIcYkT4V8&w=1572&h=484&nonsense=endWith.png](https://docs.google.com/drawings/pub?id=1n4Ai_A5LxWkymQBnc1E4DvBvsQ4pku5S6RwIcYkT4V8&w=1572&h=484&nonsense=endWith.png)

Papyrus saves its models in two files, one using a ".uml" extension and the other using a  ".di2" extension. The ".di2" file contains all the graphical information, whereas the actual model information is stored in the ".uml" file. The ".di2" file is not needed, since this project has no use for the graphical information on the EAST-ADL side.

In the picture above the file named "demo.uml" represents a EAST-ADL model (demo) saved by Papyrus.

This project offers:
  * A Java implementation which ties an Eclipse pop-up menu to ".uml" and ".simulink" files.
  * An ATL Description of a Transformation between EAST-ADL and SimuLink models.
  * A Java implementation which verifies meta-model compliance for EAST-ADL and Simulink models.

So, a user can use Eclipse to invoke an ATL Transformation (1 in the picture above) of "demo.uml" to a file describing a model that complies to our Simulink metamodel. This model, saved in the file "demo.simulink" can be seen as an intermediate representation of the demo model. A user can also use Eclipse to validate EAST-ADL and Simulink models.

MATLAB, due to its ability to use Java classes, can be used to read "demo.simulink" using EMF Java classes and create a Simulink model corresponding to the demo EAST-ADL model (3 in the picture above).

However, information which is not important for compatibility, such as graphical information, naming conventions, etc., can be missing in the ".simulink" files after an ATL Transformation from ".uml" files. So, these files have to be pre-processed first (2 in the picture above).

The code for these steps are a mix of native MATLAB and Java code, invoked from the MATLAB Simulink GUI.

This project offers:
  * A Java implementation which adds missing layout information to ".simulink" files.
  * A MATLAB implementation which sets up the MATLAB environment (adds to the GUI, adds Java classpath and adds the MATLAB source path).
  * A Java implementation which reads the offered ECore models in the ".simulink" files into memory and allows MATLAB to query the structure.
  * A MATLAB implementation (".m" files) which creates Simulink objects from the queried structure.

Changes done to the imported demo model in Simulink to define the behavior of the demo system will be reflected in the model exported back to Papyrus. The steps when exporting back to Papyrus are similar, with some extra small steps.

This project offers:
  * The MATLAB implementation mentioned above also allows tagging parts of models for exchange and converting MATLAB Subsystems into MATLAB Libraries (the later because this project does not support transformation of regular MATLAB Subsystems).
  * A Java implementation which creates ECore models through an external API.

The offered parts are described in greater detail in [Important Classes](ImportantClasses.md).

## More to read ##
  * [Limitations](Limitations.md) of the exchange process.
  * [Supported workflows](SupportedWorkflows.md): starting at either end.
  * Matthias Biehl, Carl-Johan Sjöstedt, Martin Törngren, "A Modular Tool Integration Approach - Experiences from two Case Studies,"  3rd Workshop on Model-Driven Tool & Process Integration (MDTPI2010), June 16 2010, Paris, France. Available: http://www.md.kth.se/~biehl/files/papers/toolint.pdf
  * Presentation, including the mapping (on a high level of abstraction) http://www.md.kth.se/~biehl/files/papers/SimulinkDemo.pdf
  * Carl-Johan Sjöstedt, Jianlin Shi, Martin Törngren, David Servat, DeJiu Chen, Viktor Ahlsten, Henrik Lönn, "Mapping Simulink to UML in the design of embedded systems: Investigating scenarios and transformations http://www.md.kth.se/~carlj/Papers/Omer4.pdf