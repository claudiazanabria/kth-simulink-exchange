-- @path SIM=http:///se.kth.md.attest2/Simulink/3.0
-- @path EST=http://www.papyrusuml.org/EAST-ADL2/1


module east2simulink;
create OUT1 : SIM from IN1 : EST;


-- NOTES:
-- The following elements are created at the top level but are NOT needed.
-- SystemReference for FAA.
-- Inports and Outports are duplicated.
-- All these can be safely ignored.

rule TopLevelADLContainer {
	from
		s : EST!Model	-- Model is a UML class	
	using {
		rootSys : EST!AnalysisFunctionType = 
			EST!AnalysisLevel.allInstancesFrom('IN1')->first()
				.functionalAnalysisArchitecture.type;

		allFunctionTypes : Set(EST!AnalysisFunctionType) =
			EST!AnalysisFunctionType.allInstancesFrom('IN1');
	}		
	to
		t : SIM!Model (
			name   	<- s.name,
			root	<- rootSys, 
			parts	<- allFunctionTypes
			)
}	

rule FunctionTypes2Subsystems {
	from
		s : EST!AnalysisFunctionType
		
	to	
		aSystem : SIM!System ( 
				name 		<- s.base_Class.name,
				children	<- s.part,
				inports		<- s.convertInports(),
				outports 	<- s.convertOutports(),
				lines		<- s.connector
			)
}


rule FunctionPrototypes2SystemReference {
	from 
		s : EST!AnalysisFunctionPrototype
	to
		t : SIM!SystemReference (
				name 		<- s.base_Property.name,
				target		<- s.type
				--parent is not set. It can be calculates later on.
			)
}

unique lazy rule Inports {
	from
		s : EST!FunctionFlowPort
	to
		t : SIM!Inport(
			name	<- s.base_Port.name
			)
}

unique lazy rule Outports {
	from 
		s : EST!FunctionFlowPort 
	to 
		t : SIM!Outport (
			name 	<- s.base_Port.name
			)
}


helper context EST!AnalysisFunctionType def : convertInports() : Set(SIM!Inport) = 
	self.port->select( aPort | aPort.isInport() )
		->collect( aPort | thisModule.Inports(aPort) );

helper context EST!AnalysisFunctionType def : convertOutports() : Set(SIM!Outport) = 
	self.port->select( aPort | aPort.isOutport() )
		->collect( aPort | thisModule.Outports(aPort) );

helper context EST!FunctionFlowPort def : isOutport() : Boolean = 
	self.direction = #out;

-- ATL does not support the symbol #in, 
-- so to check for #in we use oposite of #out
helper context EST!FunctionFlowPort def : isInport() : Boolean = 
	not self.isOutport();


rule Connector2Lines {
-- Lines that are misplaced in the source get empty endpoints
-- Misplacaed in the sense that they should belong to another FunctionType

	from
		s : EST!FunctionConnector
	to
		t : SIM!Line (
				name 		<- s.base_Connector.name,
				source		<- thisModule.Inports( s.port->first() ),
				destination <- thisModule.Outports( s.port->last() )
			)
}
