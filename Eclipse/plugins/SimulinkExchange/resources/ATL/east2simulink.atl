-- @path SIM=http:///se.kth.md.attest2/Simulink/3.0
-- @path EST=http://www.papyrusuml.org/EAST-ADL2/1


module east2simulink;
create OUT1 : SIM from IN1 : EST;


-- Missing rules (TODO):
-- ADLInOutFlowPort
-- ADLPortGroup
-- ADLClientServerPort


-- NOTES:
-- A SystemReference for FAA is unecesarily generated, 
-- and ignored further down the chain.

rule TopLevelADLContainer {
	from
		--s : EST!ADLSystemModel ( s = thisModule.ValidADLSystem )
		s : EST!Model	-- Model is a UML class
	to
		t : SIM!Model (
			name   	<- s.name,
			root	<- thisModule.findRootSystem(), 
			parts	<- thisModule.findAllFunctionTypes()
			)
}
	

helper def : findAllFunctionTypes() : Set(EST!AnalysisFunctionType) =
	EST!AnalysisFunctionType.allInstancesFrom('IN1');

helper def : findRootSystem() : EST!AnalysisFunctionType =
	EST!AnalysisLevel.allInstancesFrom('IN1')->first()
		.functionalAnalysisArchitecture.type;


rule FunctionTypes2Subsystems {
	from
		s : EST!AnalysisFunctionType
		
	to	
		aSystem : SIM!System ( 
				name 		<- s.base_Class.name,
				children	<- s.part,
				inports		<- s.convertInports(),
				outports 	<- s.convertOutports()
--				lines		<- s.connector
			)
}


rule FunctionPrototypes2SystemReference {
	from 
		s : EST!AnalysisFunctionPrototype
	to
		t : SIM!SystemReference (
				name 		<- s.base_Property.name,
				target		<- s.type
				--parent is not set. It can be calculates later on.
			)
}

unique lazy rule Inports {
	from
		s : EST!FunctionFlowPort
	to
		t : SIM!Inport(
			name	<- s.base_Port.name
			)
}

unique lazy rule Outports {
	from 
		s : EST!FunctionFlowPort 
	to 
		t : SIM!Outport (
			name 	<- s.base_Port.name
			)
}


helper context EST!AnalysisFunctionType def : convertInports() : Set(SIM!Inport) = 
	self.port->select( aPort | aPort.isInport() )
		->collect( aPort | thisModule.Inports(aPort) );

helper context EST!AnalysisFunctionType def : convertOutports() : Set(SIM!Outport) = 
	self.port->select( aPort | aPort.isOutport() )
		->collect( aPort | thisModule.Outports(aPort) );

helper context EST!FunctionFlowPort def : isOutport() : Boolean = 
	self.direction = #out;

-- ATL does not support the symbol #in, 
-- so to check for #in we use oposite of #out
helper context EST!FunctionFlowPort def : isInport() : Boolean = 
	not self.isOutport();


--rule ConnectorPrototype2Lines {
---- Lines that are misplaced in the source get empty endpoints
---- Misplacaed in the sense that they should belong to another FunctionType
--
--	from
--		s : EST!ADLConnectorPrototype ( s.isConnectedToFAA() )
--
--	using {
--			srcPort : EST!ADLFlowPort = s.flowPort->first();
--			dstPort : EST!ADLFlowPort = s.flowPort->last();
--		}
--
--	to
--		t : SIM!Line (
--				name <- s.name,
--				source			<- srcPort,
--				destination 	<- dstPort
--				--parent		<-
--			)
--}
--
--lazy abstract rule FlowPorts {
--	from
--		s : EST!FunctionFlowPort
--	to
--		t : SIM!Port (
--				name 	<- s.base_Port.name,
--				parent	<- s.refImmediateComposite()
--			)
--}

---- Returns the FunctionPrototype containing the flowPort
--helper context EST!ADLFlowPort def : findFunctionPrototypeContainer() : 
--	EST!ADLFunctionPrototype = 
--		self.findFunctionTypeContainer().findFunctionPrototypeContainer();
--
--
---- Return the FunctionPrototype containing the functionType
--helper context EST!ADLFunctionType def : findFunctionPrototypeContainer() :
--	EST!ADLFunctionPrototype = EST!ADLFunctionPrototype.allInstancesFrom('IN1')->
--		any( aFunctionProto | aFunctionProto.type = self );
--
--
---- Returns the FunctionType containing the flowPort
--helper context EST!ADLFunctionPrototype def : findFunctionTypeContainer() :
--	EST!ADLFunctionType = EST!ADLFunctionType.allInstancesFrom('IN1')->
--	--ERROR: This function breaks if two systems include the same FunctionPrototypes !?!	
--	any( aFunctionType | aFunctionType.part->includes( self ) );
--
--
---- Returns the FunctionType containing the flowPort
--helper context EST!ADLFlowPort def : findFunctionTypeContainer() : 
--	EST!ADLFunctionType = EST!ADLFunctionType.allInstancesFrom('IN1')->
--		any( aFunctionType | aFunctionType.flowPort->includes( self ) );
--
--
--helper context EST!ADLFlowPort def : findPortNumber() : Integer =
--	-- Uses reflection to find port type.
--		self.findFunctionTypeContainer().flowPort->
--			select(aPort|aPort.oclType() = self.oclType() )->
--			indexOf(self);
--	
--
